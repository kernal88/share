php5中 无论在哪里改变对象的属性，都可以改变它

静态属性表示类所有的对象都共享的属性，一旦改变，所有的对象都跟着变化。可用类直接访问

extends 表示继承

子类中的函数调用父类的函数，要使用parent

private表示这个属性只有类里面的函数才能访问

果private 的话，子类就无法访问了，但又不希望随便都可以修改某些属性。
那么可以用protected，protected 的属性可以被子类的函数访问。

子类的函数如果和父类函数同名，除非另行说明，否则子类的对象默认
调用子类内的函数。

假如为了规范处理，我们把隐形的能力建立一个类，然后把飞行能力放一个类，那么人族的侦
察机怎么处理？

函数封装的是功能代码，而用类可以将函数和数据都封装在一起

46
查明可能发生的变化所需要的时间越长，创建正确的分类就越困难
(加减法在很多地方应用了，再考虑抽象、分离，就很困难)

open-closed id the nuclear of oop

对呈现出频繁变化的部分做出抽象，但对每部分都抽象不是好事，拒绝不成熟抽象和抽象本身同样

电脑硬件的发展，和oo发展思想完全类似。也说明时间万物都遵循某种类似规律，谁先把握规律，谁就能最早成为强者

针对接口编程，不要对实现编程，电脑硬件都是针对接口设计的，若针对实现，内存就要对应具体某品牌主板，就会出现换内存需要换主板的尴尬

LSP代换原则：子类必须能够替换掉他们父类

生物中企鹅鸵鸟虽不会飞，但属于鸟，但oo中父类鸟有飞的行为，子类拥有父类所有非private的行为和属性才能算继承。也正因为如此，使得继承复用成为可能，只有当子类可以替换父类时，父类才能真正被复用，而子类也能够在父类基础上增加新行为

LSP代换使open-closed成为可能，正式由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展

依赖倒转其实是谁都别依靠谁，除了约定的接口，大家都可以灵活自如

蓝屏是内存问题或内存与主板不兼容

装饰模式是为已有功能动态添加更多功能的一种方式

初始化信息不发生变化的情况下，克隆是最好办法，这及隐藏了对象创建的细节，有对性能是大大提高

很多证书在国外很有权威认证性，只是国人和国内的教育培训机构太会应对考试，这样的结果是直接毁了这个证书，继而让用人单位对这证书失望

PHP5中通过将数据封装、声明为私有的(private)，再提供一个或多个公开的（public）方法实现对该属性的操作，以实现下述目的：
隐藏一个类的实现细节；
防止对封装数据的未经授权的访问。使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；

类被封装，不分配内存，调用某个属性（方法），它才生效

私有变量（属性）即private不能被外界访问 即不能echo

封装和隐藏（private）可以保护数据安全性

重写专指方法，子类权限不能大于父类。但属性随意

parent::也专指方法，不限父类，爷类也可

构造方法是默认的公有方法（构造方法不要设置成私有的）
类中只能声明一个构造方法，而是只有在每次创建对象的时候都会去调用一次构造方法，
不能主动的调用这个方法，所以通常用它执行一些有用的初始化任务。比如对成属性在创建对象的
时候赋初值

通过在类定义中使用关键字" var "来声明变量，即创建了类的属性,虽然在声明成员属性
的时候可以给定初始值， 但是在声明类的时候给成员属性初始值是没有必要的，比如说要
是把人的姓名赋上“张三”,那么用这个类实例出几十个人，这几十个人都叫张三了

__set()、__get()、__isset()、__unset() 这四个方法都是我们添加到对象里面的，在需要时自动调
用的，来完成在对象外部对对象内部私有属性的操作,均可设置为private
外部对对象内私有属性set get isset unset时会报错，这样设置就可直接访问。
问题是，这样就失去封装性，直接public算了。。。。

因为PHP 没有名字空间的概念，在同一个页面和被包含的页面中不能定义相同名称的方
法，也不能定义和PHP 给我提供的方法重名，当然在同一个类中也不能定义相同名称的方法

从抽象的角度来讲， 一个“学生”不能有两种“说话”的方法，就算你定义了两个不同的说话的
方法，可以实现你想要的功能，被继承过来的那个“说话”方法可能没有机会用到了，而且是继承
过来的你也删不掉。这个时候我们就要用到覆盖了

PHP 里面不能定义同名的方法， 但是在父子关系的两个类中，我们可以在子类中定
义和父类同名的方法，这样就把父类中继承过来的方法覆盖掉了

__construct = 类名
parent:: = 父类该方法名
self:: = 该静态方法所属的类名

只能用来定义类和定义方法，不能使用final 这个关键字来定义成员属性，因为
final 是常量的意思，我们在PHP 里定义常量使用的是define()函数，所以不能使用final 来定义
成员属性 
使用final 关键标记的类不能被继承、覆盖，是最终版本

类的静态变量、静态方法，非常类似全局变量，能够被所有类的实例共享

静态成员是在类第一次加载的时候就创建的，所以在类的外部不需要对象而使用类名就可
以访问的到静态的成员

静态的成员不是在每个对象内部存在
的，但是每个对象都可以共享，所以我们如果使用对象访问成员的话就会出现没有这个属性定义，
使用对象访问不到静态成员的

如果PHP 中可以使用对象访问静态成员的话，我们也尽量不要去使用，因为静态的
成员我们在做项目的时候目的就是使用类名去访问

类里面的静态方法只能访问类的静态的属性，在类里面的静态方法是不能访问类的非静态成员
要想在本类的方法中访问本类的其它成员，我们需要使用$this 这个引用，
而$this 这个引用指针是代表调用此方法的对象，我们说了静态的方法是不用对象调用的，而是使
用类名来访问，所以根本就没有对象存在，也就没有$this 这个引用了，没有了$this 这个引用就
不能访问类里面的非静态成员，又因为类里面的静态成员是可以不用对象来访问的，所以类里面的
静态方法只能访问类的静态的属性，既然$this 不存在，在静态方法中访其它静态成员我们使用的
是一个特殊的类“self”；self 和$this 相似，只不过self 是代表这个静态方法所在的类

类中有非静态方法被self:: 调用时，系统会自动将这个方法转换为静态方法

非静态方法里可不可以访问静态成员呢，当然也是可以的了，但是也不能使用“$this”引用
也要使用类名或是 self::成员属性的形式

用“const”修饰的成员属性的访问方式和“static”修饰的成员访问的方式差
不多，也是使用“类名”，在方法里面使用“self”关键字。但是不用使用“$”符号，也不能使
用对象来访问。

只要一个类里面有一个方法是抽象方法，那么这个类就要定义为抽象类

$this 永远是调用它的对象的引用

接口中不可有变量，但可有const关键字声明的常量,常量就是静态的

接口特殊性导致不用在其内写 public abstract

class Math{
	const PI = 3.14;
}
echo Math::PI;     //如同静态变量，可直接用::输出

abstract function() {};也算是重写，只要参数数量与原方法相等